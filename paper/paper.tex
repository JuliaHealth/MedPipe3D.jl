
% JuliaCon proceedings template
\documentclass{juliacon}
\setcounter{page}{1}

\begin{document}

\input{header}

\maketitle

\begin{abstract}
%% Text of abstract
Medical image segmentation is a rapidly developing field of computer vision, which requires knowledge in radiologic imaging, mathematics, and computer science. Multiple software packages have been developed to  assist researchers in the field; however, due to the rapidly changing scientific environment, some of these tools are no longer  effective for some users. This is the case of Julia language users that require support for an interactive programming development style that is unpopular among traditional software tools. Another characteristic of modern programming for three-dimensional medical imaging data is GPU acceleration, which can deliver outstanding improvements in algorithms' performance when working on objects that can be represented as large arrays, such as those present in 3D medical imaging. This work presents new sets of Julia language software tools that are designed to fulfil emerging needs. The tools include a GPU-accelerated medical image viewer with annotation possibility that is characterised by a convenient programming interface. The work then presents a CUDA-accelerated medical segmentation metrics tool that supplies state-of-the-art implementations of algorithms required for the quantification of similarity between algorithm outputs and gold standards. Lastly, the work presents a set of utility tools that connect the packages mentioned above using an HDF5 file system.

\keywords{CUDA,computer tomography,medical image segmentation  }


\end{abstract}

%% keywords here, in the form: keyword \sep keyword
%% PACS codes here, in the form: \PACS code \sep code


%% \linenumbers

%% main text


\section{Introduction}
One field of computer vision that  has an immediate influence on societal wellbeing is the automation of diagnoses based on medical imaging. To recognise and label both pathological and physiological structures, multiple algorithms, which are known as medical image segmentation algorithms, can be used. As in any other field of computer vision, supervised, semisupervised, and nonsupervised methods can be distinguished. The methods can also be divided into automatic and semiautomatic ones; in the latter case, user input is required.

A typical workflow includes:
\begin{enumerate}
  \item visual inspection of  the data and exploration of the metadata
  \item feature engineering to represent the data in the most effective way in the chosen model
  \item selection of the model with consideration for possible assumptions that could be encoded within it as inductive bias
  \item selection of the segmentation metric and cost function.
  \item after evaluation and debugging, reconsideration of  design choices to improve the model's performance
  \item reiteration until the model's performance is satisfactory
\end{enumerate}

For all of the steps above, multiple software tools are widely available; to implement any model robustly and efficiently, however, the appropriate tools must be used for a given domain. This involves considerations on the size of single image files, performance constraints, interoperability of the required tools, and the language of the package interface.

In 3D medical image segmentation, one common difficulty is the size of the images, which can frequently reach multiple gigabytes per patient. This demands parallelisation to achieve acceptable execution times. At present, the most effective parallelisation in medical imaging can be achieved using GPU architectures. Among tools used for medical segmentation metrics, the possibility of GPU acceleration is highly desirable. Such tools are available, for example, in MONAI \cite{MONAI} or tensorflow \cite{tensorflow}; most, however, have their interfaces written in the Python programming language. This is an advantage because it makes collaboration between data scientists easier. Python is most popular data science language, and is considered easy to use; however, it also leads to some specific issues, the most important of which is relatively low performance. Popular Python libraries usually solve this problem by having the main code written in a high-performance language like C++ and supplying a Python interface to it. Apart from the additional work that is necessary to write and maintain such libraries, they also encounter significant problems with the interoperability of Python packages. This is known as the 'two-language' problem. One of the best solutions to it is the Julia programming language \cite{Julia}. The Julia ecosystem contain multiple packages that support varius aspects of GPU programming, including CUDA.jl \cite{besard2019prototyping} and ParallelStencil.jl \cite{ParallelStencil}.

\section{Visual inspection}

\begin{figure}[t!]
	\centering
	\includegraphics[width=0.5\textwidth]{PETCTCORONAL.png}
	\caption{Transverse display FDG PET/CT.}
	\label{fig:PETCTCORONAL}
	\centering
\end{figure}

The visual inspection of 3D data demands specialised software. Although multiple high-quality applications created for viewing and annotating are available, most of them require special configuration and are not always convenient to use during the rapid development phase. In Julia, a typical workflow includes constant experimentation using the interactive environment, read--eval--print loop (REPL), which increases development efficiency. However, current 3D visualisation tools are poorly suited to such a workflow. To address this issue, this authors have a developed new 3D visualisation and annotation tool, MedEye3d \cite{Mitura2021}, which is characterised by high performance, low memory consumption, and an interface that is designed to be easily accessible from the REPL command line or from keyboard shortcuts. Due to the intended usage pattern, no typical graphical user interface elements (such as buttons)  are included. This decreases the amount of screen space occupied by the application and makes it easier to use  as a separate window next to chosen the Julia integrated development environment (IDE). Despite this purposeful simplicity, all crucial functionalities required for displaying 3D medical imaging are easily accessible via keyboard shortcuts. In the case of the development of semiautomatic algorithms, annotations on the image are easy to perform and the results are immediately available in the Julia REPL for further processing. An example of the display can be seen in Figure \ref{fig:PETCTCORONAL}.

\section{Problem Statement and Research Objectives}
Although Julia is characterised by a plethora of excellent scientific software packages, to the best knowledge of these authors, it lacks some of the tools necessary for 3D medical segmentation. The most problematic seem to be the lack of efficient visualisation and evaluation tools. The goals of this work are to provide the scientific community with those missing software solutions, and by doing so, to popularise study on 3D medical segmentation in the Julia language community.


\section{Evaluation metrics}

The selection of evaluation metric is dictated by two primary considerations. The first is that the chosen metric quantifies the similarity between some gold standard and the output of the algorithm. To assess this, some measure of domain knowledge related to the data on which the algorithm will be run is necessary. The second requirement is that the chosen metric function possess  the properties required for optimisation. In most cases, this means that the gradient of the metric can be defined so that it can be used, for example, in back propagation of the neural network. The second requirement leads, in some cases, to modifications of the metric function itself. The metric that is subjected to the optimisation algorithm is called the cost function, and, by convention, small values should represent large similarity between compared data. The first consideration is, arguably, more important from an algorithm design perspective, as a researcher must be certain that a reduction in the cost function value truly leads to increased similarity between the measured entities in a meaningful way. The cost functions traditionally defined for standard images are frequently unable to be used to measure the similarity between the gold standard and the algorithm output in medical image segmentation. This problem is particularly evident in the case of three-dimensional data.

In medical segmentation, some of the most influential works that describe segmentation metrics are those published by Renard et al \cite{Nature} and by Taha et al \cite{TahaMainSegm}. Those works stressed that optimal metrics may differ depending on the problem. For example, in multiple cases, large interclass discrepancy exists in relation to its representation in the data; for this reason, one of the most commonly used segmentation metrics is Dice. In the work of Taha et al \cite{TahaMainSegm}, multiple algorithms, including the Dice metric, are implemented using a confusion matrix (which includes a number of true positive, false positive, true negative, and false negative entries). This group of algorithms opens new opportunities to use multiple metrics simultaneously without incurring significant performance penalties, and to validate using other criteria, such as visual inspection. Frequently, not only the number of voxels that are correctly or incorrectly labeled is important, but also their spatial distribution. In this case, distance metrics like Mahalanobis or Hausdorff distance should be considered. Algorithms that consider distance are typically far more computationally intensive.

The subfield of machine learning in medical imaging segmentation metrics is dominated by two main frameworks: Pymia \cite{Pymia} and MONAI \cite{MONAI}. In both cases, the user interface is written in Python. MONAI \cite{MONAI} implements multiple  highly-optimised metrics that are particularly prevalent in neural networks with available Compute Unified Device Architecture (CUDA) acceleration; yet, it lacks most of those described in \cite{TahaMainSegm}. MONAI is  based on PyTorch \cite{pytorch}. Pymia \cite{Pymia} implements all of the algorithms described in \cite{TahaMainSegm} and is framework independent, but lacks GPU acceleration, which may drastically limit its performance in cases of large data objects---and such cases are highly common in modern medical imaging. 


\section{Data management}
Medical imaging data in clinical settings is usually stored in the Digital Imaging and Communications in Medicine (DICOM) \cite{dicom} standard. Apart from storing the data that represents a given variable in each voxel of a study, DICOM is able to hold rich metadata, such as patients' names and ages, and details about the acquisition technique.  The standard was primarily designed for optimising display and storage of data and not its processing; thus, operations like partial loading or data queries lack efficiency.

Hierarchical Data Format HDF5 \cite{hdf5} originates from a high-performance computing ecosystem. It is recognised as an efficient and convenient data format for storing and processing medical imaging data \cite{hdf5Medical}. Apart from its high performance, the format is characterised by its ability to save and process multidimensional data, and by its optimisation for large multidimensional arrays. This characteristic is uncommon, as most traditional data formats are optimised for tabular data, and store image data in the form of binary object data types (BLOB), with a limitation that no queries can be performed for data in a BLOB. HDF5, contrarily, makes queries and partial loading of stored multidimensional arrays. As with other popular data formats, it has programming APIs in multiple widely-used languages, such as Python, C++, and Julia.

The HDF5 data format seems optimal for processing 3D medical imaging, as it has excellent support for multidimensional data, supports the saving of the metadata of those arrays (like the DICOM format), and has good query performance and convenient programming interfaces (like traditional database formats). Another unique feature is the possibility of direct data loading from persistent storage to GPU global memory without intermediate storage in a CPU's RAM  \cite{hdf5GPU}; this feature, however, will not be used in this work for the sake of simplicity.

\subsection{Experiments}
\subsubsection{Evaluation metrics}
All experiments were conducted on a Windows PC (Intel Core I9 10th gen., GeforceRTX 3080), using data from the CT-ORG \cite{CTORG} dataset on images of size ($512 \times 512 \times 826$). The time needed to calculate the metrics was estimated in the case of the Julia code using BenchamrkTools.jl \cite{BenchmarkTools}. For testing the Python libraries, an internal python module, timeit, was used. The results of the experiments mentioned above are summarised in Figure \ref{fig:bk}. In all cases, the data was already stored in RAM memory for CPU computations, or in GPU memory for CUDA computations; for this reason, memory transfer times were not included.

\begin{figure}[h!]
	\centering
	\includegraphics[width=\columnwidth]{bk.png}
	\caption{Comparison of median times needed to calculate given metrics in log scale. For MONAI, only the CUDA-accelerated algorithm was considered. The dimensionality of the data was ($ 512x512x826 $).  }
	\label{fig:bk}
\end{figure}

\subsubsection{Visualisation}

To measure the actual time necessary to  render the GPU, synchronisation was performed using the OpenGl glFinish() function.
Cross-section plane translation is defined as changing the single coordinate that defines the plane in a chosen cross-section. The time needed to accomplish this is measured as the number of milliseconds between rendering the commands using BenchamrkTools.jl \cite{BenchmarkTools}. 

Response to the left click time of the mouse was measured as the difference between the time reported in the callback registered to the GLFW window and the end of the execution of a command designed to render the visible change on the chosen texture.

\begin{figure}[t!]
	\centering
	\includegraphics[width=\columnwidth]{Przechwytywanie.png}
	\caption{Execution times depending on function and machine used.}
	\label{fig:Przechwytywanie}
	\centering
\end{figure}

The time required for a cross-section plane change (for example, from transverse to sagittal) was defined as the difference in time between the invocation of a GLFW callback (which itself is invoked by appropriate user interaction) and the end of the rendering function execution.
The results of the experiments are summarised in Figure \ref{fig:Przechwytywanie}. It is clearly visible that the time required for completion of functions in the case of the Ubuntu laptop was longer; yet, considering its far inferior hardware, this was to be expected. The reduced performance had no effect on the user experience.


Memory use was tested using actual data from PET/CT. The data uploaded to the display constituted three matrices of Float32, UInt8,  and Int16 data types, as well as a 2000x8000 matrix that holds text data. 
In the case of the Windows 10 system, dedicated GPU memory use was evaluated using the Details section of the Task Manager and oscillated between between 38K and 39.5K. In the case of the Ubuntu laptop, Nvidia System Monitor was used to estimate GPU memory usage, and dedicated GPU memory usage oscillated around 21MB. 

\section{Conclusions}
Medical image segmentation is a complex task that requires knowledge from medicine, engineering, and mathematics. To make the task of developing such algorithms as manageable as possible, multiple software tools have been developed. However, due to rapid advancements in machine learning and in medical imaging, the need for further specialisation of these tools has emerged. Although most of the needs of the research community may be met by existing solutions, there are use cases in which existing solutions are inadequate. One such case pertains to researchers who wish to work in Julia programming language either due to its rich ecosystem of scientific libraries or due to its high performance, both in terms of execution time and development time. One requirement of developing medical segmentation algorithms in Julia is that all necessary steps be completed using Julia---with the possible exception of preprocessing, which often must be performed only once.

The programming framework presented in this work is a response to the changing software environment, and is implemented in an emerging programming language, Julia. It also uses GPU acceleration, which delivers vast performance improvements over CPU-based algorithms, and uses modern programming approaches like reactive functional style in GUI programming. Critically for convenient rapid prototyping, all of the programming process can be performed with the help of Julia REPL. It is noteworthy that multiple metrics implemented in the presented software are, to the best knowledge of these authors, characterised by the shortest execution times---not only in Julia, but also in all popular open source solutions. 

To make the development process even easier, the final section of this work presents an additional set of utility functions, which, for example, add a persistence layer  using the HDF5 system. All of the tools presented in this work are highly composable and may be used in isolation, which constitutes another crucial advantage. 

\section{Acknowledgement}
The package is open source and available on GitHub at: https://github.com/jakubMitura14/MedPipe3D.jl under the Apache license. In case of any feature requests, bug reporting, or contribution proposals, please contact the corresponding author via LinkedIn: https://linkedin.com/in/jakub-mitura-7b2013151/ or in the issues section of the GitHub repository.


\bibliography{ref}

\input{bib.tex}

\end{document}

% Inspired by the International Journal of Computer Applications template
